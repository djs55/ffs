#!/usr/bin/env python

import urlparse
import subprocess
import xapi
import xapi.volume
import xapi.common


class Implementation(xapi.volume.SR_skeleton):

    def create(self, dbg, uri, configuration):
        u = urlparse.urlparse(uri)
        # sometimes a user can believe that a device exists because
        # they've just created it, but they don't realise that the actual
        # device will be created by a queued udev event. Make the client's
        # life easier by waiting for outstanding udev events to complete.
        code = subprocess.call(["udevadm", "settle"])
        # if that fails then log and continue
        if code != 0:
            xapi.common.log("udevadm settle exitted with code %d" % code)

        p = subprocess.Popen(["mkfs.btrfs",
                              u.path,
                              "-f"],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        stdout, stderr = p.communicate()
        if p.returncode != 0:
            raise xapi.volume.Unimplemented("mkfs.btrfs failed on %s" % u.path)
        return

if __name__ == "__main__":
    cmd = xapi.volume.SR_commandline(Implementation())
    cmd.create()
